<?php


namespace App\Services;

use Illuminate\Support\Facades\Http;
use App\Models\User;
use Illuminate\Support\Facades\Log;
use Carbon\Carbon;

class ChallongeOauthService
{
    public function requestWithUser($user, $method, $url, $options = [])
    {
        // refresh token if expired
        if ($user->challonge_token_expires_at && Carbon::now()->greaterThan($user->challonge_token_expires_at)) {
            $this->refreshToken($user);
            $user->refresh();
        }

        $token = $user->challonge_access_token;
        $client = Http::withToken($token)->acceptJson();

        $resp = $client->send($method, $url, $options);
        if ($resp->status() === 401 && $user->challonge_refresh_token) {
            // try refresh then retry once
            $this->refreshToken($user);
            $user->refresh();
            $client = Http::withToken($user->challonge_access_token)->acceptJson();
            $resp = $client->send($method, $url, $options);
        }

        return $resp;
    }

    public function refreshToken($user)
    {
        try {
            $res = Http::asForm()->post('https://api.challonge.com/oauth/token', [
                'grant_type' => 'refresh_token',
                'refresh_token' => $user->challonge_refresh_token,
                'client_id' => config('services.challonge.client_id'),
                'client_secret' => config('services.challonge.client_secret'),
            ]);

            if (! $res->successful()) {
                Log::error('Challonge refresh failed', ['status' => $res->status(), 'body' => $res->body()]);
                return false;
            }

            $body = $res->json();
            $user->update([
                'challonge_access_token' => $body['access_token'] ?? $user->challonge_access_token,
                'challonge_refresh_token' => $body['refresh_token'] ?? $user->challonge_refresh_token,
                'challonge_token_expires_at' => isset($body['expires_in']) ? Carbon::now()->addSeconds($body['expires_in']) : null,
            ]);

            return true;
        } catch (\Throwable $e) {
            Log::error('Challonge refresh exception', ['err' => $e->getMessage()]);
            return false;
        }
    }

    protected function baseHeaders(User $user = null)
    {
        if ($user && $user->challonge_access_token) {
            return Http::withToken($user->challonge_access_token)->acceptJson();
        }
        return Http::acceptJson();
    }

    public function startTournament(User $user, string $challongeTournamentId)
    {
        $res = $this->requestWithUser($user, 'post', "https://api.challonge.com/v1/tournaments/{$challongeTournamentId}/start.json");
        return $res;
    }

    public function pushEventGames(User $user, $localEvent)
    {
        // localEvent expected to have participants and games info
        // create participants first
        foreach ($localEvent->participants as $p) {
            $payload = ['participant' => ['name' => $p->name, 'email' => $p->email ?? null]];
            $this->requestWithUser($user, 'post', "https://api.challonge.com/v1/tournaments/{$localEvent->challonge_tournament_id}/participants.json", [
                'form_params' => $payload
            ]);
        }

        // optionally start tournament after participants added
        $this->startTournament($user, $localEvent->challonge_tournament_id);

        // matches are generated by Challonge on start; if you need to push local matches, iterate:
        foreach ($localEvent->games as $g) {
            // If local has mapping to challonge_match_id, update score
            if (!empty($g->challonge_match_id)) {
                $this->updateMatchScore($user, $localEvent->challonge_tournament_id, $g->challonge_match_id, "{$g->score_a}-{$g->score_b}");
            }
        }

        return true;
    }

    public function updateMatchScore(User $user, string $tournamentId, $challongeMatchId, string $scoresCsv)
    {
        // update match scores on Challonge (PUT)
        $payload = ['match' => ['scores_csv' => $scoresCsv]];
        $res = $this->requestWithUser($user, 'put', "https://api.challonge.com/v1/tournaments/{$tournamentId}/matches/{$challongeMatchId}.json", [
            'form_params' => $payload
        ]);
        return $res;
    }

    public function fetchBracket(User $user, string $tournamentId)
    {
        $participants = $this->requestWithUser($user, 'get', "https://api.challonge.com/v1/tournaments/{$tournamentId}/participants.json");
        $matches = $this->requestWithUser($user, 'get', "https://api.challonge.com/v1/tournaments/{$tournamentId}/matches.json");

        return [
            'participants' => $participants->successful() ? $participants->json() : null,
            'matches' => $matches->successful() ? $matches->json() : null,
        ];
    }
}